//#define KP 320         //Angle  proportional controller gain [LSB/deg/loop]
//#define KD 0       // Angle rate derivative controller gain [LSB/deg/loop]
//#define KI 0       // https://github.com/TKJElectronics/BalancingRobotArduino/blob/master/BalancingRobot.h


//#define FIX     2	// '-' forward
#define TFT_ON_OFF  0	// 0 to turn TFT off








#include <signal.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>
#include "L3G.h"
#include "LSM303.h"
#include "sensor.c"
#include "gyro.h"
#include "GPIOpinsMotorConstroller.h"
#include "TFT.c"
#include "i2c-dev.h"
#include "encoders.c"

#define X   0
#define Y   1
#define Z   2
#define DT 0.02         // [s/loop] loop period
#define AA 0.98         // complementary filter constant

#define A_GAIN 0.0573      // [deg/LSB]
#define G_GAIN 0.00875     // [deg/s/LSB]
#define MAX_RATE 180.0     // [deg/s]
#define RAD_TO_DEG 57.29578
#define M_PI 3.14159265358979323846

#define ON 1
#define OFF 0





void  INThandler(int sig)
{
        signal(sig, SIG_IGN);
        shutBcmDown();
	setMotorSpeeds(0,0,0);
	closeSDL();
        exit(0);
}

int mymillis()
{
	struct timeval tv; 
	gettimeofday(&tv, NULL);
	return (tv.tv_sec) * 1000 + (tv.tv_usec)/1000;
}

int timeval_subtract(struct timeval *result, struct timeval *t2, struct timeval *t1)
{
    long int diff = (t2->tv_usec + 1000000 * t2->tv_sec) - (t1->tv_usec + 1000000 * t1->tv_sec);
    result->tv_sec = diff / 1000000;
    result->tv_usec = diff % 1000000;
    return (diff<0);
}

int main(int argc, char *argv[])
{
        //Exit if not enough parameters are added with the executable
        if(argc != 6 ) {
                fprintf(stderr, "Usage:  %s <KP> <KI> <KD> <KW> <FIX>\n", argv[0]);
                exit(1);
        }



	float KP = atof(argv[1]);
	float KI = atof(argv[2]);
	float KD = atof(argv[3]);
	float KW = atof(argv[4]);

	signed int FIX = atof(argv[5]);

	float rate_gyr_y = 0.0;   // [deg/s]
	float rate_gyr_x = 0.0;    // [deg/s]
	float rate_gyr_z = 0.0;     // [deg/s]

	signed int accel_x_zero = 0;
	signed int accel_y_zero = 0;
	signed int accel_z_zero = 0;
	signed int gyro_y_zero = 0;
	signed int gyro_x_zero = 0;
	signed int gyro_z_zero = 0;

	int  *Pacc_raw;
	int  *Pmag_raw;
	int  *Pgyr_raw;
	int  acc_raw[3];
	int  mag_raw[3];
	int  gyr_raw[3];
	Pacc_raw = acc_raw;
	Pmag_raw = mag_raw;
	Pgyr_raw = gyr_raw;

//	float output = 0.0;
	int output = 0;
//	float outputReverse = 0.0;
	int outputReverse = 0.0;

	float gyroXangle = 0.0;
	float gyroXangleLast = 0.0;
	float gyroYangle = 0.0;
	float gyroZangle = 0.0;
	float AccYangle = 0.0;
	float AccXangle = 0.0;
	float CFangleX = 0.0;

	int TFTtimer = mymillis();
	int startInt  = mymillis();
	struct  timeval tvBegin, tvEnd,tvDiff;

	signed int acc_y = 0;
	signed int acc_x = 0;
	signed int acc_z = 0;
	signed int gyr_x = 0;
	signed int gyr_y = 0;
	signed int gyr_z = 0;

	float pTerm = 0.0;
	float iTerm = 0.0;
	float dTerm = 0.0;
	float lastAngle = 0.0;

//	int wheelVelocity = 0;
//	int wheelPosition = 0;
//	int lastWheelPosition = 0;
	int leftWheelVelocity = 0;
	int rightWheelVelocity = 0;
	int lastLeftEncoderValue = 0;
	int lastRightEncoderValue = 0;

	int motorPower = ON;
	int motorPowerTimer = mymillis();

        signal(SIGINT, INThandler);

	enableIMU();
	if (TFT_ON_OFF)	setupTFT();
	setupEncoders();
        SetPinsOut();
	setUpMotor();

	gettimeofday(&tvBegin, NULL);



	//counter_clockwise();



	int i;
	for (i = 0; i < 100000; i++)
	{

	startInt = mymillis();


	//read ACC and GYR data
	readMAG(Pmag_raw);
	readACC(Pacc_raw);
	readGYR(Pgyr_raw);

  	//Remove offset from raw values.  (im not sure if this is even needed)
  	acc_x = ( *acc_raw - accel_x_zero );
  	acc_y = (*(acc_raw+1) - accel_y_zero);
  	acc_z = (*(acc_raw+2) - accel_z_zero);

  	//Remove offset from raw values.  (im not sure if this is even needed)
	gyr_y = (*(gyr_raw+1) - gyro_y_zero);
  	gyr_x = (*gyr_raw - gyro_x_zero);
	gyr_z = (*(gyr_raw+2) - gyro_z_zero);

	//Convert Gyro raw to degrees per second
	rate_gyr_y = (float) gyr_y * G_GAIN;
	rate_gyr_x = (float) gyr_x * G_GAIN;
	rate_gyr_z = (float) gyr_z * G_GAIN;



	//Calculate the angles from the gyro
	gyroXangle+=rate_gyr_x*DT;
	gyroYangle+=rate_gyr_y*DT;
	gyroZangle+=rate_gyr_z*DT;




	//Convert Accelerometer values to degrees
	AccXangle = (float) (atan2(acc_y,acc_z)+M_PI)*RAD_TO_DEG;
	AccYangle = (float) (atan2(acc_x,acc_z)+M_PI)*RAD_TO_DEG;
	
	
	AccXangle += FIX;

	//Change the rotation value of the accelerometer to -/+ 180
	if (AccXangle >180)
	{
		AccXangle -= (float)360.0;
	}
	if (AccYangle >180)
		AccYangle -= (float)360.0;
		

//      Complementary filter used to combine the accelerometer and gyro values.
	CFangleX=AA*(CFangleX+rate_gyr_x*DT) +(1 - AA) * AccXangle;


	leftWheelVelocity = lastLeftEncoderValue - leftEncoderValue;
	rightWheelVelocity = lastRightEncoderValue - rightEncoderValue;
	lastLeftEncoderValue = leftEncoderValue;
	lastRightEncoderValue = rightEncoderValue;



	if (digitalRead (RF1) == 1) KP += 1;
	if (digitalRead (RF2) == 1) KI += 1;
	if (digitalRead (RF3) == 1) KP -= 1;
	if (digitalRead (RF4) == 1) KI -= 1;



	pTerm = KP * CFangleX;
	iTerm += KI * CFangleX;
	dTerm = KD *  (CFangleX - lastAngle);
	lastAngle = CFangleX;
	output = pTerm + iTerm + dTerm;


//	wheelPosition = (leftEncoderValue + rightEncoderValue)/2;
//	wheelVelocity = lastWheelPosition - wheelPosition;
//	lastWheelPosition = wheelPosition;
//	output+= KW * wheelVelocity;
//	printf ("wheelVelocity %i \t ",wheelVelocity);






	// Clip as float (to prevent wind-up).
	if(iTerm < -128.0) { iTerm = -128.0; } 
	if(iTerm > 128.0) { iTerm = 128.0; }
	if(output < -100.0) { output = -100.0; } 
	if(output > 100.0) { output = 100.0; }

	//Only update TFT every 150ms
	if((TFT_ON_OFF) & (mymillis() - TFTtimer > 150))
	{
		writetoTFT(gyroXangle,AccXangle,CFangleX,output);
		TFTtimer = mymillis();
	}

	printf ("GyroX  %7.3f \t AccXangle %7.3f \t CFangleX %7.3f \t output %d \t P %7.3f \t I %7.3f \t D %7.3f",gyroXangle,AccXangle,CFangleX,output, pTerm, iTerm, dTerm);
	

	if  (CFangleX > 25 || CFangleX <-25) {
		pwmWrite (PWN_PIN, 0);
		printf("###STOP###");
	output = 0;
	}
        if (CFangleX < 0 && motorPower==ON){
		setMotorSpeeds(output,leftWheelVelocity,rightWheelVelocity);
	}
	else if (CFangleX > 0 && motorPower==ON){
		setMotorSpeeds(output,leftWheelVelocity,rightWheelVelocity);
        }




	if (digitalRead(RESET_GYRO)== HIGH)
	{
		printf ("## Resetting Gyro ##");
		if(TFT_ON_OFF )tftMessage("Reset", "Gyro");
		gyroXangle=0.0;
		iTerm = 0.0;
	}

	if ((digitalRead(STOP_START)== HIGH) && ((mymillis() - motorPowerTimer) > 1000))
	{
		if (motorPower == ON)
		{
			printf ("## Motors OFF ##");
			if(TFT_ON_OFF)tftMessage("Motors", "OFF");
			motorPower = OFF;
			setMotorSpeeds(0,0,0);
		}
		else
		{
			printf ("## Motors ON ##");
			if(TFT_ON_OFF )tftMessage("Motors", "ON");
			motorPower = ON;
		}
			motorPowerTimer = mymillis();

	}

	printf("\n");

	//Each loop should be at least 20ms.
        while(mymillis() - startInt < 20)
        {
            usleep(100);
        }

	printf("Loop \t%d ", mymillis()- startInt);
	

    }


	closeSDL();
	//end
	gettimeofday(&tvEnd, NULL);
	// diff
	timeval_subtract(&tvDiff, &tvEnd, &tvBegin);
	printf("Time seconds:%ld.%06ld\n", tvDiff.tv_sec, tvDiff.tv_usec);

}

